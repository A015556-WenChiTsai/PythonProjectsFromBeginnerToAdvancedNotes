# 珠璣妙算 (Mastermind) - Python 實作練習

這是一個經典的邏輯解謎遊戲「珠璣妙算 (Mastermind)」的 Python 實作版本。
本專案不僅實作了遊戲邏輯，更展示了從「初學者」邁向「進階開發者」所需的程式碼規範與技巧。

## 📂 專案檔案結構

- `19_mastermind.py`: 遊戲主程式。
- `mastermind.log`: 遊戲執行時自動生成的日誌檔案（記錄操作與錯誤）。

## 🚀 核心學習重點 (Key Takeaways)

透過閱讀與執行此程式碼，你可以學習到以下 Python 進階技巧：

### 1. 工程化日誌 (Logging)
不再依賴 `print` 進行除錯。
- 使用 `logging` 模組將遊戲過程、警告與錯誤寫入 `mastermind.log`。
- 學習設定 Log 格式 (`format`) 與編碼 (`encoding='utf-8'`)。

### 2. 資料結構的高效運用
- **`collections.Counter`**: 利用計數器物件的交集運算 (`&`)，優雅地計算「顏色正確但位置錯誤」的數量，避免複雜的巢狀迴圈。
- **`Set` (集合)**: 使用 `issubset` 快速驗證使用者輸入是否包含非法字元。
- **`Tuple` (元組)**: 定義不可變的常數 (`COLORS`)，節省記憶體並防止意外修改。

### 3. Pythonic 語法
- **Type Hinting**: 使用 `typing` 模組 (`List`, `Tuple`) 增加程式碼可讀性與維護性。
- **`for-else` 迴圈**: 處理「迴圈正常結束且未被中斷」的邏輯（用於判斷玩家是否耗盡嘗試次數）。
- **`zip` 函數**: 同時遍歷「正確答案」與「玩家猜測」兩個列表。

### 4. 錯誤處理 (Error Handling)
- 使用 `try-except` 區塊捕捉未預期的異常。
- 使用 `logging.exception` 自動記錄完整的錯誤堆疊 (Traceback)，便於事後排查問題。

## 🎮 遊戲規則

1. 系統會隨機生成一組 **4 個字元** 的密碼。
2. 顏色代碼範圍：`R` (紅), `G` (綠), `B` (藍), `Y` (黃), `O` (橘), `P` (紫)。
3. 玩家有 **10 次** 嘗試機會。
4. 每次猜測後，系統會提示：
   - **位置正確**: 顏色與位置完全符合的數量。
   - **顏色正確**: 顏色存在但位置錯誤的數量。

## 🛠️ 如何執行

確保你的環境已安裝 Python 3.6+。

```bash
python 19_mastermind.py

你好！我是你的技術總監。很高興看到你寫出了這麼完整的 Mastermind 遊戲代碼。

這份程式碼其實寫得非常有水準！你用到了 `logging`（日誌）、`Type Hinting`（型別提示）、`try-except`（錯誤捕捉），甚至還有 `Counter` 這種進階的集合運算，這已經超越了普通初學者的範疇。

針對你感到困惑的三個核心邏輯，我會用**圖解**的方式幫你拆解，這也是我們在做 Code Review 時常用的溝通方式。

---

### 1. 視覺化拆解：`sum(c == g for c, g in zip(code, guess))`

這行程式碼是用來計算 **「位置正確且顏色正確」** 的數量。

#### 想像場景：拉鍊 (Zipper)
`zip` 函式就像拉鍊一樣，把兩個列表（List）同一位置的元素扣在一起。

假設：
*   **Code (密碼):** `['R', 'G', 'B', 'Y']`
*   **Guess (猜測):** `['R', 'O', 'B', 'P']`

**步驟 A：`zip(code, guess)` 的運作**
它會把上下對齊，變成一對一對的 Tuple：
```text
位置 0: ('R', 'R')
位置 1: ('G', 'O')
位置 2: ('B', 'B')
位置 3: ('Y', 'P')
```

**步驟 B：`c == g` (判斷相等)**
Python 會遍歷每一對，判斷它們是否一樣：
```text
('R', 'R') -> True  (一樣)
('G', 'O') -> False (不一樣)
('B', 'B') -> True  (一樣)
('Y', 'P') -> False (不一樣)
```

**步驟 C：`sum(...)` (總和)**
在 Python 中，**`True` 被視為 `1`，`False` 被視為 `0`**。
所以 `sum` 其實是在做數學加法：
```text
  1 (True)
+ 0 (False)
+ 1 (True)
+ 0 (False)
-----------
  2
```
**結論：** 有 2 個位置是完全正確的。

---

### 2. 視覺化拆解：`Counter(code)`

`Counter` 是一個「計數器」，你可以把它想像成**分類桶**。它不管順序，只管「有幾個」。

假設：
*   **Code:** `['R', 'R', 'G', 'B']` (注意這裡有兩個 R)

**運作方式：**
程式會把球丟進對應顏色的桶子裡計數。

```text
原始列表: [R, R, G, B]

   R桶      G桶      B桶      Y桶
  [RR]      [G]      [B]      [ ]
   ↓        ↓        ↓        ↓
 { "R": 2,  "G": 1,  "B": 1 }  <-- 這就是 Counter 物件
```
它回傳的是一個字典（Dictionary），告訴你每個顏色出現了幾次。

---

### 3. 視覺化拆解：`sum((code_counts & guess_counts).values())`

這行程式碼是用來計算 **「顏色正確（不管位置）」** 的總數。這裡最難懂的是 `&` 符號。

在 `Counter` 的世界裡，`&` 代表 **「交集」 (Intersection)**，也就是取兩者中 **較小 (Minimum)** 的那個數字。

**情境模擬：**
*   **Code (密碼):** `['R', 'R', 'G', 'B']` (2個R, 1個G, 1個B)
*   **Guess (猜測):** `['R', 'G', 'G', 'Y']` (1個R, 2個G, 1個Y)

**步驟 A：建立 Counter**
```text
Code計數:  {'R': 2, 'G': 1, 'B': 1}
Guess計數: {'R': 1, 'G': 2, 'Y': 1}
```

**步驟 B：執行 `&` (取交集/最小值)**
我們要算的是「猜對了幾個顏色」。
*   **R:** 密碼有2個，你猜了1個。你猜對了幾個 R？ **1個** (取 min(2, 1))。
*   **G:** 密碼有1個，你猜了2個。你猜對了幾個 G？ **1個** (多猜的沒用，取 min(1, 2))。
*   **B:** 密碼有1個，你沒猜。 **0個**。
*   **Y:** 密碼沒有，你猜了1個。 **0個**。

結果產生一個新的 Counter：
```text
Intersection: {'R': 1, 'G': 1}
```

**步驟 C：`.values()` 和 `sum()`**
*   `.values()` 取出數字部分：`[1, 1]`
*   `sum()` 加總：`1 + 1 = 2`

**結論：** 你總共猜對了 2 個顏色（不管位置在哪）。

---

### 4. 技術總監的 Code Review (你需要加強的部分)

雖然你的程式碼結構很好，但有幾個地方在「正式開發環境」中需要注意：

#### (1) 致命傷：殘留的測試代碼 (Hardcoded Testing Data)
在 `generate_code` 函式中：
```python
def generate_code() -> List[str]:
    code = [random.choice(COLORS) for _ in range(CODE_LENGTH)]
    code = list(('R', 'G', 'B', 'Y')) # <--- 這裡！
    # ...
```
**問題：** 你把密碼寫死了！不管隨機生成什麼，最後都會變成 `R, G, B, Y`。
**建議：** 在提交程式碼前，務必刪除這種測試用的代碼。如果需要測試，應該使用 `unittest` 或 `pytest` 框架來固定隨機種子 (Random Seed)，而不是修改主程式邏輯。

#### (2) 邏輯清晰度：`correct_color` 的計算
```python
# 你的寫法
total_color_match = sum((code_counts & guess_counts).values())
correct_color = total_color_match - correct_position
```
**點評：** 這段邏輯非常聰明，數學上完全正確。
*   `total_color_match` 包含了「位置對」和「位置錯」的所有顏色。
*   減去「位置對」的，剩下的就是「顏色對但位置錯」的。
**建議：** 這部分保持這樣很好，但註解要寫得更清楚（你已經寫了，這點很棒）。初學者常犯的錯誤是試圖用很多 `if-else` 去算 B (顏色對位置錯)，結果邏輯大亂。你用集合運算解決是最佳解。

#### (3) `for-else` 語法的使用
```python
for attempt in range(1, TRIES + 1):
    # ...
    if correct_position == CODE_LENGTH:
        break
else:
    # 失敗訊息
```
**點評：** Python 的 `for-else` 是一個很特別但**容易被誤解**的語法。它的意思是「如果迴圈**沒有**被 `break` 中斷，就執行 else」。
**建議：** 雖然你用對了，但在團隊開發中，很多其他語言轉過來的工程師看不懂這個語法。
更通用的寫法是使用一個 `Flag` 變數：
```python
is_win = False
for attempt in range(...):
    if win:
        is_win = True
        break

if not is_win:
    print("失敗...")
```
不過既然你是 Python 學習者，保留 `for-else` 是展現 Python 特性的好方式，只要你自己清楚它的邏輯即可。

#### (4) 輸入處理的強健性
在 `get_valid_guess` 中：
```python
user_input = input(...).upper().strip()
```
**問題：** 如果使用者直接按 `Ctrl+C` (中斷) 或 `Ctrl+D` (EOF)，這裡會報錯，雖然你在 `main` 有 `try-except`，但那是全域捕捉。
**建議：** 可以在這裡單獨處理中斷，讓程式優雅退出。

### 總結
你現在的程度已經能寫出結構漂亮、邏輯正確的 Python 程式碼。
**下一步建議：**
1.  **學習單元測試 (Unit Testing)：** 解決「手動改代碼來測試」的問題。
2.  **物件導向 (OOP)：** 試著把這個遊戲封裝成一個 `MastermindGame` 類別，而不只是散落的函式。

加油！這份作業如果滿分 100，我會給你 90 分。剩下的 10 分就是把那行寫死的 `code = ...` 拿掉！

這是一個非常好的問題！這行程式碼展現了 **「現代 Python (Modern Python)」** 的寫作風格。

這行程式碼結合了兩個概念：**型別提示 (Type Hinting)** 與 **不可變資料結構 (Immutable Data Structure)**。

讓我們把它拆解成三個部分來理解：

### 1. `COLORS: ... = ("R", ...)` —— 為什麼用圓括號 `()` 而不是方括號 `[]`？

這是 **Tuple (元組)** 與 **List (串列)** 的區別。

*   **List `[]` (可變)**：像是你的「購物清單」，你可以隨時新增、刪除或修改裡面的項目。
*   **Tuple `()` (不可變)**：像是刻在石碑上的「十誡」，一旦定義了就**不能修改**。

**為什麼這裡要用 Tuple？**
因為 `COLORS` 是遊戲的**規則設定**。
*   **安全性**：我們不希望程式跑到一半，不小心執行了 `COLORS.append("Black")` 或者 `COLORS[0] = "X"`，導致遊戲崩潰或邏輯錯誤。使用 Tuple，如果有人試圖修改它，程式會直接報錯 (TypeError)，保護資料不被篡改。
*   **語意明確**：當其他工程師（或未來的你）看到 Tuple，就知道「這是一個固定的設定值，不需要去動它」。

---

### 2. `: Tuple[str, ...]` —— 這是什麼咒語？

這叫做 **型別提示 (Type Hinting)**。
Python 本身是動態語言，你不寫這個程式也能跑。但加上這個是為了**給「人」看，以及給「編輯器 (IDE)」看**。

讓我們細看括號裡的內容：

#### `Tuple`
告訴讀者：這個變數的型態是 Tuple。

#### `[str, ...]`
這是最容易讓人困惑的地方。為什麼後面有三個點點 `...` (Ellipsis)？

在 Python 的 `typing` 模組規則中，Tuple 的寫法有兩種：

*   **寫法 A：固定長度與型態**
    如果你寫 `Tuple[str, str]`，代表這個 Tuple **只能有兩個元素**，且兩個都是字串。
    *   `("A", "B")` -> ✅ 合法
    *   `("A", "B", "C")` -> ❌ 編輯器會警告你長度不對

*   **寫法 B：不定長度，但型態一致 (我們用的這個)**
    如果你寫 `Tuple[str, ...]`，代表這個 Tuple **可以有任意長度**，但**裡面的每一個元素都必須是字串 (str)**。
    *   `("A", "B")` -> ✅ 合法
    *   `("A", "B", "C", "D", "E")` -> ✅ 合法
    *   `("A", 123)` -> ❌ 編輯器會警告你 123 不是字串

**總結：** `Tuple[str, ...]` 的意思是 **「這是一個由字串組成的 Tuple，長度不限」**。

---

### 3. 為什麼要這樣寫？有什麼好處？

身為技術總監，我會要求團隊這樣寫，原因有三：

1.  **IDE 的自動補全 (Auto-completion)**：
    當你在後面的程式碼打 `COLORS[0].` 時，因為編輯器知道它是 `str`，它會自動跳出字串的方法（如 `.lower()`, `.strip()`）給你選。如果你沒寫型別提示，編輯器可能不知道那是甚麼，就不會提示。

2.  **提早發現錯誤 (Static Analysis)**：
    如果你不小心在 `COLORS` 裡放了一個數字 `1`，像 VS Code 或 PyCharm 這種強大的編輯器會直接畫紅線警告你：「嘿！你說這裡是字串，但你放了整數！」這能讓你在執行程式前就修好 Bug。

3.  **文件化 (Documentation)**：
    這行程式碼本身就是文件。初學者一看到 `: Tuple[str, ...]`，不用去讀後面的內容，馬上就知道這個變數的結構是什麼。

### 簡單對照表

| 寫法 | 意義 | 專業度 |
| :--- | :--- | :--- |
| `COLORS = ("R", "G")` | 這是一個 Tuple，內容隨意。 | ⭐ (普通) |
| `COLORS: tuple = ("R", "G")` | 這是一個 Tuple，但不確定裡面裝什麼。 | ⭐⭐ (尚可) |
| `COLORS: Tuple[str, str] = ("R", "G")` | 這是一個 Tuple，嚴格規定只有兩個字串。 | ⭐⭐⭐ (嚴格) |
| **`COLORS: Tuple[str, ...] = ("R", "G")`** | **這是一個 Tuple，裡面全是字串，長度不限。** | **⭐⭐⭐⭐⭐ (專業)** |

所以，這行程式碼是為了讓程式更**安全**、更**好讀**、且更**容易維護**。